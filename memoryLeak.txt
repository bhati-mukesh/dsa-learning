‚úÖ What is a Memory Leak in React?
A memory leak occurs when memory (data, resources, subscriptions) used by your app is no longer needed but never released ‚Äî so it keeps accumulating, leading to slowdowns, crashes, or browser performance issues.


üìå In React, common causes of memory leaks:
Async operations (fetch, setTimeout) not cancelled
Subscriptions (WebSocket, EventListener) not cleaned up
Components trying to update state after unmount
Unused refs or DOM nodes retained unintentionally
Large state trees kept in memory (e.g., in Redux or context)


üîç Signs of Memory Leaks
Console warning:
    ‚ö†Ô∏è Can't perform a React state update on an unmounted component
Increased RAM usage over time
Slow re-renders, degraded performance
Unresponsive UI after prolonged usage


‚úÖ Real-World Example of Memory Leak
useEffect(() => {
  const timer = setTimeout(() => {
    setData("value"); // ‚ö†Ô∏è Will throw warning if component unmounted
  }, 2000);
}, []);
If the component unmounts before the timeout fires, you get:
In console Warning: ‚ÄúCan't perform a React state update on an unmounted component.‚Äù



‚úÖ How to Prevent Memory Leaks in React

Here are practical strategies (with examples) to prevent memory leaks in React apps:
1Ô∏è‚É£ Use Cleanup in useEffect
useEffect(() => {
  const interval = setInterval(() => {
    console.log("ping");
  }, 1000);

  return () => clearInterval(interval); // ‚úÖ Clean up on unmount
}, []);
‚úÖ Always return a cleanup function in useEffect.

2Ô∏è‚É£ Cancel Promises / Async Tasks Manually
useEffect(() => {
  let isCancelled = false;

  fetchUserData().then((data) => {
    if (!isCancelled) setUser(data);
  });

  return () => {
    isCancelled = true; // ‚úÖ Prevent state update
  };
}, []);
Or use AbortController with Axios or fetch.


3Ô∏è‚É£ Use AbortController for fetch requests
useEffect(() => {
  const controller = new AbortController();

  fetch('/api/user', { signal: controller.signal })
    .then(res => res.json())
    .then(data => setData(data))
    .catch(err => {
      if (err.name !== 'AbortError') console.error(err);
    });

  return () => controller.abort(); // ‚úÖ Cancel request on unmount
}, []);


4Ô∏è‚É£ Use useIsMounted() hook (as discussed earlier)
const isMounted = useIsMounted();
    useEffect(() => {
    fetchData().then(data => {
        if (isMounted.current) {
        setData(data);
        }
    });
}, []);
‚úÖ Prevents state update if component unmounted.


5Ô∏è‚É£ Cleanup Subscriptions and Listeners
useEffect(() => {
  window.addEventListener("resize", handleResize);
  return () => window.removeEventListener("resize", handleResize);
}, []);
‚úÖ Same for WebSocket, custom events, etc.


6Ô∏è‚É£ Avoid Retaining Unused Refs or Objects
Avoid doing this:
    const bigDataRef = useRef(hugeObject);
If hugeObject isn‚Äôt needed anymore, this can keep it in memory. Clean it up if needed, or set ref.current = null.


7Ô∏è‚É£ Avoid Keeping Stale Data in Global State (Redux, Context)
Don‚Äôt store large data objects in Redux or context if they aren‚Äôt needed anymore.
‚úÖ Use resetState() actions or clearData() to free memory when navigating away or on logout.


8Ô∏è‚É£ Use Lazy Loading & Code Splitting
React.lazy()
React.Suspense
Dynamic imports
‚úÖ Keeps memory footprint smaller by loading only what‚Äôs needed.


‚úÖ What to Say in Interviews
‚ÄúMemory leaks in React often come from side effects like API calls, timers, or event listeners that continue running after a component unmounts. I prevent them by always cleaning up inside useEffect, cancelling requests using AbortController, and using a custom useIsMounted() hook to avoid updating state on unmounted components. Also, we manage global state carefully to avoid retaining stale or large objects.‚Äù